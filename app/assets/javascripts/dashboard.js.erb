(function() {

  var app = angular.module('recruitmentApp', ['ngAnimate', 'google-maps', 'ui.bootstrap']);

  app.controller('contractorDashController', ["$scope", "$http", function($scope, $http) {

    $scope.showSpinner = {}
    // creates a generic map to be updated at later one
    $scope.map = {
        center: {
            latitude: 45,
            longitude: -73
        },
        zoom: 3
    };

    // creates a generic map marker to be updated at later one
    $scope.marker = {
        id:0,
        coords: {
            latitude: 51.5,
            longitude: -0
        }
    }

    // request to the server to return the current user type.  Either Employee or contractor
    $http.get('/dashboard/get_current_user_type.json').success(function(data){

      var current_user_type = data
      
    // if the current user is Contractor, load the initial information. 
      if (current_user_type == "Contractor") {

        $scope.contractor = [];
        
    // Centers the usermap on the User and puts a marker
        $http.get('/dashboard/get_current_contractor.json').success(function(data){
          $scope.contractor = data
          $scope.map.center.latitude = $scope.contractor.address.latitude
          $scope.map.center.longitude = $scope.contractor.address.longitude
          $scope.map.zoom = 8
          
          $scope.marker = {
              id:0,
              coords: {
                  latitude: $scope.contractor.address.latitude,
                  longitude: $scope.contractor.address.longitude
              }
          }

    // displays how far the user is prepared to travel.  needs refactoring
          $scope.options = [{ name: "unlimited", id: 50000 }, { name: "1000 miles", id: 1000 }, { name: "500 miles", id: 500 }, { name: "200 miles", id: 200 }, { name: "100 miles", id: 100 }, { name: "50 miles", id: 50 }, { name: "20 miles", id: 20 }];      
          for(var i = 0; i < $scope.options.length; i++) { 
            if ($scope.options[i].id ==  $scope.contractor.distance_travel){
              $scope.selectedOption = $scope.options[i]
            } 
          }
        })

    // get the jobs to display for the user.  currently returns all the jobs in seed data, but this can easily be refactored.  

        $http.get('/jobs.json').success(function(data) {
          $scope.jobs = data
        })

      }

      // if the current user is Employee, load the initial information. 
      if (current_user_type == "Employee") {

        $scope.employee = []; 


      // needs refactoring, this can be done in one request.    
        $http.get('/dashboard/get_current_employee.json').success(function(data){
          $scope.employee = data
          $http.get('/dashboard/get_current_company_jobs.json').success(function(data){
            $scope.companyjobs = data
          })

        })     
      }
    })


  // returns the list of potential contrators 

    $scope.getPotentialContractors = function (index){
      $http.put('/dashboard/put_potential_contractors.json', {job_id: $scope.selectedCompanyJob.id, company_id: $scope.employee.company.id}).success(function(data){

          data.forEach( function(potentialContractor)  {
              potentialContractor.canTravel = $scope.userCanTravel(potentialContractor)
              potentialContractor.hasQualifications = $scope.userHasQualifications(potentialContractor)
              potentialContractor.showedInterest = $scope.userShowedinterest(potentialContractor)
              potentialContractor.contacted = $scope.userContacted(potentialContractor)
              potentialContractor.offered = $scope.userOffered(potentialContractor)
              potentialContractor.accepted = $scope.userAccepted(potentialContractor)
              potentialContractor.rejected = $scope.userRejected(potentialContractor)
              potentialContractor.companyBlockContractor = $scope.companyblockcontractor(potentialContractor)
              potentialContractor.contractorFavourite = $scope.contractorfavourite(potentialContractor) 
              // potentialContractor.comments = $scope.comments(potentialContractor)
          })
          $scope.potentialcontractors = data
          $scope.showSpinner[index] = false
      })
    }

    $scope.viewComments = function (potentialContractor) {
      $scope.specificComments = potentialContractor.comments
      $scope.specificNameInModal = potentialContractor.name
      console.log($scope.specificNameInModal)
    }

    $scope.userHasSearch = function(job) {
      var interested = false
      for(var i =0 ; i < job.jobsearches.length; i++) {
        if (job.jobsearches[i].contractor_id == $scope.contractor.id) {
          if ((job.jobsearches[i].interested == false) || (job.jobsearches[i].interested == null) || (job.jobsearches[i].interested == [])) {
            interested = false
          }else{
            interested = true
          }
        }
      }
      return interested
    }



// changes the availability of a contractor

    $scope.available = function() {

      $http.put('dashboard/update_available_now.json', { id: $scope.contractor.id }).success(function (data){
        if ($scope.contractor.available_now) {
           $scope.contractor.available_now = false
        } else {
           $scope.contractor.available_now = true
          }
      }) 
    }

// updates how far a contractor is willing to travel in the database    
    $scope.update = function() {
       
        $http.put('dashboard/update_distance_travel.json', { id: $scope.contractor.id, distance_travel: $scope.selectedOption.name }).success(function (data){
      })
    }

// check if a contractor is interested in a particular job
    $scope.showjobinterest = function(job) {

      $http.put('dashboard/show_job_interest.json', { contractor_id: $scope.contractor.id, job_id: job.id }).success(function (data){
        $http.get('/jobs.json').success(function(data) {
          $scope.jobs = data
        })
      })
    }

// updates if a user is interested in a particular job
    $scope.userShowedinterest = function(potentialcontractor) {
      var interested = false
      for(var i =0 ; i < potentialcontractor.jobsearches.length; i++) { 
        if (potentialcontractor.jobsearches[i].job_id == $scope.selectedCompanyJob.id) {
          if ((potentialcontractor.jobsearches[i].interested == false) || (potentialcontractor.jobsearches[i].interested == null) || (potentialcontractor.jobsearches[i].interested == [])) {
            interested = false
          }else{
            interested = true
          }
        }
      }
      return interested
    }

// Checks the distance between a contractor and a job, and checks whether the contractor is willing to travel the distance to it.  
    $scope.userCanTravel = function(potentialcontractor) {
      var cantravel = false
      lat1 = potentialcontractor.address.latitude
      lon1 = potentialcontractor.address.longitude
      lat2 = $scope.selectedCompanyJob.address.latitude
      lon2 = $scope.selectedCompanyJob.address.longitude
      maxdistance = potentialcontractor.distance_travel


      var R = 6371; // km
      var φ1 = lat1 * Math.PI / 180;
      var φ2 = lat2 * Math.PI / 180;
      var Δφ = (lat2-lat1)* Math.PI / 180;
      var Δλ = (lon2-lon1)* Math.PI / 180;

      var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      var d = R * c;

      if (d < maxdistance) {
        return true
      }else{
        return false
      }

    }


// Checks the distance between a contractor and a job, and checks whether the contractor is willing to travel the distance to it.  

    $scope.userHasQualifications = function(potentialcontractor) {

      var hasQualifications = false

      contractorqualifications = potentialcontractor.qualifications
      jobqualifications = $scope.selectedCompanyJob.qualifications


      for(var i =0 ; i < contractorqualifications.length; i++) {
        for(var ii =0 ; ii < jobqualifications.length; ii++) {

          if (contractorqualifications[i].name == jobqualifications[ii].name) {
            hasQualifications = true
          }
        }
      }
      return hasQualifications
    }

// in the employee dashboard, checks whether a user's status is available. 
    $scope.userAvailable = function(potentialcontractor) {

      p = potentialcontractor.available_now  
      return p

    }


// for a particular job, checks whether a user has been contacted.  
    $scope.userContacted = function(potentialcontractor) {
      var contacted = false
      for(var i =0 ; i < potentialcontractor.jobsearches.length; i++) { 
        if (potentialcontractor.jobsearches[i].job_id == $scope.selectedCompanyJob.id) {
          if (potentialcontractor.jobsearches[i].contacted == true){
            return true
          }
        }
      }
      return false
    }

// toggles status of User contacted for a specific job.    
    $scope.contactUser = function(potentialcontractor) {
      $scope.userContacted(potentialcontractor) = true
      $http.put('dashboard/contact_user.json', { contractor_id: potentialcontractor.id, job_id: $scope.selectedCompanyJob.id }).success(function (data){
          $scope.getPotentialContractors()
      })
      
    }

// for a particular job, checks whether a user has been made an offer  
    $scope.userOffered = function(potentialcontractor) {
      var offered = false
      for(var i =0 ; i < potentialcontractor.jobsearches.length; i++) { 
        if (potentialcontractor.jobsearches[i].job_id == $scope.selectedCompanyJob.id) {
          if (potentialcontractor.jobsearches[i].offered == true){
            return true
          }
        }
      }
      return false
    }

// toggles status of User offered for a specific job.    
    $scope.offerUser = function(potentialcontractor) {
      $http.put('dashboard/offer_user.json', { contractor_id: potentialcontractor.id, job_id: $scope.selectedCompanyJob.id }).success(function (data){
          $scope.getPotentialContractors()
      })      
    }

// for a particular job, checks whether a user has accepted an offer
    $scope.userAccepted = function(potentialcontractor) {
      for(var i =0 ; i < potentialcontractor.jobsearches.length; i++) { 
        if (potentialcontractor.jobsearches[i].job_id == $scope.selectedCompanyJob.id) {
          if (potentialcontractor.jobsearches[i].accepted == true){
            return true
          }
        }
      }
      return false
    }

  
// toggles status of User accepted for a specific job.  
    $scope.acceptUser = function(potentialcontractor , index) {
    $scope.showSpinner[index] = true;
    // $scope.message = 'Loading...'
    console.log($scope.showSpinner)
      $http.put('dashboard/accept_user.json', { contractor_id: potentialcontractor.id, job_id: $scope.selectedCompanyJob.id }).success(function (data){
          $scope.getPotentialContractors(index)
      }) 
    }

// for a particular job, checks whether a user has rejected an offer
    $scope.userRejected = function(potentialcontractor) {
      for(var i =0 ; i < potentialcontractor.jobsearches.length; i++) { 
        if (potentialcontractor.jobsearches[i].job_id == $scope.selectedCompanyJob.id) {
          if (potentialcontractor.jobsearches[i].rejected == true){
            return true
          }
        }
      }
      return false
    }

// toggles status of User accepted for a specific job.
    $scope.rejectUser = function(potentialcontractor) {

      $http.put('dashboard/reject_user.json', { contractor_id: potentialcontractor.id, job_id: $scope.selectedCompanyJob.id }).success(function (data){
          $scope.getPotentialContractors()
      }) 
    }

//  Popup message with the contractors phone number.  
    $scope.phoneUser = function(potentialcontractor) {

      alert("Name: " + potentialcontractor.name + "\nPhone number: " + potentialcontractor.phone)
      
    }

    $scope.contractorfavourite = function(potentialcontractor) {
      var favouritecontractor = false
      for(var i = 0 ; i < potentialcontractor.relationships.length; i++) {
        if (potentialcontractor.relationships[i].company_id == $scope.employee.company.id) {
          if ((potentialcontractor.relationships[i].favouritecontractor == false) || (potentialcontractor.relationships[i].favouritecontractor == null) || (potentialcontractor.relationships[i].favouritecontractor == [])) {
            favouritecontractor = false
          }else{
            favouritecontractor = true
          }
        }
      }
      return favouritecontractor
    }

    $scope.togglecontractorfavourite = function(potentialcontractor) {

      $http.put('dashboard/put_toggle_contractor_favourite.json', { contractor_id: potentialcontractor.id, company_id: $scope.employee.company.id}).success(function (data){
          $scope.getPotentialContractors()
      }) 
    }

    $scope.companyblockcontractor = function(potentialcontractor) {
      var companyblockcontractor = false
      for(var i = 0 ; i < potentialcontractor.relationships.length; i++) {
        if (potentialcontractor.relationships[i].company_id == $scope.employee.company.id) {
          if ((potentialcontractor.relationships[i].companyblockcontractor == false) || (potentialcontractor.relationships[i].companyblockcontractor == null) || (potentialcontractor.relationships[i].companyblockcontractor == [])) {
            companyblockcontractor = false
          }else{
            companyblockcontractor = true
          }
        }
      }
      return companyblockcontractor
    }

    $scope.togglecompanyblockcontractor = function(potentialcontractor) {
      
      $http.put('dashboard/put_toggle_company_block_contractor.json', { contractor_id: potentialcontractor.id, company_id: $scope.employee.company.id}).success(function (data){
          $scope.getPotentialContractors()
      }) 
    }


    // $scope.togglecontractorfavourite = function(potentialcontractor) {
    //   for(var i = 0 ; i < potentialcontractor.relationships.length; i++) {
    //     if (potentialcontractor.relationships[i].company_id == $scope.employee.company.id) {
    //       if ((potentialcontractor.relationships[i].favouritecontractor == false) || (potentialcontractor.relationships[i].favouritecontractor == null) || (potentialcontractor.relationships[i].favouritecontractor == [])) {
    //         potentialcontractor.relationships[i].favouritecontractor = true
    //       }else{
    //         potentialcontractor.relationships[i].favouritecontractor = false
    //       }
    //     }
    //   }
    // }

//  start of code to change location of user to current location... to be continued... 

    // $scope.setCurrentLocation = function() {
    //   contractor = $scope.contractor
      
    //   $http.put('dashboard/set_current_location.json', { contractor_id: contractor.id }).success(function (currentuser){
         
    //      $scope.contractor.address.latitude = currentuser.address.latitude
    //      $scope.contractor.address.longitude = currentuser.address.longitude
    //    })
    // }


  }])


  app.controller('ModalDemoCtrl', ["$scope", "$modal", "$log", function($scope, $modal, $log) {
    $scope.open = function (size) {
      var modalInstance = $modal.open({
        templateUrl: 'myModalContent.html',
        controller: 'ModalInstanceCtrl',
        size: size,
        resolve: {
          items: function () {
            return $scope.specificComments;
          },
          contractor: function () {
            return $scope.specificNameInModal
          }
        }

      });

      modalInstance.result.then(function (selectedItem) {
        $scope.selected = selectedItem;
      }, function () {
        $log.info('Modal dismissed at: ' + new Date());
      });
    };
  }]);

// Please note that $modalInstance represents a modal window (instance) dependency.
// It is not the same as the $modal service used above.


  app.controller('ModalInstanceCtrl', ["$scope", "$modalInstance", "items", "contractor", function($scope, $modalInstance, items, contractor) {

    $scope.items = items;
    $scope.contractor = contractor

    $scope.ok = function () {
      $modalInstance.close();
    };

    $scope.cancel = function () {
      $modalInstance.dismiss('cancel');
    };
  }]);
  
  
  /**
   * @ngdoc service
   * @name ui.comments.commentsConfig
   * @function
   *
   * @description
   *
   * The commentsConfig service offers a provider which may be injected
   * into config blocks:
   *
   * <pre>
   * angular.module('example', ['ui.comments'])
   * .config(function(commentsConfig) {
   *   commentsConfig.set('commentController', 'MyController');
   *   commentsConfig.set({
   *     containerTemplate: 'my/custom/views/comments.html'
   *   });
   * });
   * </pre>
   *
   * Injected as a service, it is simply the configuration object in its current state.
   *
   * It is wise not to write to the service outside of config blocks, because the
   * <code>set()</code> method provides some safety checks to ensure that only valid values are
   * written. It should not be necessary for an application to inject commentsConfig anywhere
   * except config blocks.
   */
  app.provider('commentsConfig', function() {
    var config = {
      /**
       * @ngdoc property
       * @name ui.comments.commentsConfig#containerTemplate
       * @propertyOf ui.comments.commentsConfig
       *
       * @description
       *
       * The template URL for collections of comments. Support for inline templates is not yet
       * available, and so this must be a valid URL or cached ng-template
       */
      containerTemplate: 'template/comments/comments.html',
      /**
       * @ngdoc property
       * @name ui.comments.commentsConfig#commentTemplate
       * @propertyOf ui.comments.commentsConfig
       *
       * @description
       *
       * The template URL for a single comment. Support for inline templates is not yet
       * available, and so this must be a valid URL or cached ng-template
       *
       * If this template manually includes a {@link ui.comments.directive:comments comments}
       * directive, it will result in an infinite $compile loop. Instead,
       * {@link ui.comments.directive:comment comment} generates child collections programmatically.
       * Currently, these are simply appended to the body of the comment.
       */
      commentTemplate: 'template/comments/comment.html',
      /**
       * @ngdoc property
       * @name ui.comments.commentsConfig#orderBy
       * @propertyOf ui.comments.commentsConfig
       *
       * @description
       *
       * Presently, this configuration item is not actually used.
       *
       * **TODO**: Its intended purpose is to provide a default comment ordering rule. However,
       * currently there is no machinery for ordering templates at all. This is intended for a later
       * release.
       */
      orderBy: 'best',
      /**
       * @ngdoc property
       * @name ui.comments.commentsConfig#commentController
       * @propertyOf ui.comments.commentsConfig
       *
       * @description
       *
       * Custom controller to be instantiated for each comment. The instantiated controller is
       * given the property `$element` in scope. This allows the instantiated controller
       * to bind to comment events.
       *
       * The controller may be specified either as a registered controller (string), a function,
       * or by array notation.
       *
       */
      commentController: undefined,
      /**
       * @ngdoc property
       * @name ui.comments.commentsConfig#depthLimit
       * @propertyOf ui.comments.commentsConfig
       *
       * @description
       *
       * Default maximum depth of comments to display in a comments collection. When the depth
       * limit is exceeded, no further child comments collections shall be created.
       *
       * The depth limit may also be specified via the `comment-depth-limit` attribute for the
       * {@link ui.comments.directive:comments comments} directive.
       */
      depthLimit: 5
    };
    var emptyController = function() {};
    function stringSetter(setting, value) {
      if (typeof value === 'string') {
        config[setting] = value;
      }
    }
    function controllerSetter(setting, value) {
      if (value && (angular.isString(value) && value.length ||
          angular.isFunction(value) ||
          angular.isArray(value))) {
        config[setting] = value;
      } else {
        config[setting] = emptyController;
      }
    }
    function numberSetter(setting, value) {
      if (typeof value === 'number') {
        config[setting] = value;
      }
    }
    
    var setters = {
      'containerTemplate': stringSetter,
      'commentTemplate': stringSetter,
      'orderBy': stringSetter,
      'commentController': controllerSetter,
      'depthLimit': numberSetter
    };
    this.$get = function() {
      return config;
    };
    
    /**
     * @ngdoc function
     * @name ui.comments.commentsConfig#set
     * @methodOf ui.comments.commentsConfig
     * @function
     *
     * @description
     *
     * _When injected into a config block_, this method allows the manipulate the comments
     * configuration.
     *
     * This method performs validation and only permits the setting of known properties, and
     * will only set values of acceptable types. Further validation, such as detecting whether or
     * not a controller is actually registered, is not performed.
     *
     * @param {string|object} name Either the name of the property to be accessed, or an object
     *                             containing keys and values to extend the configuration with.
     *
     * @param {*} value The value to set the named key to. Its type depends on the
     *                  property being set.
     *
     * @returns {undefined} Currently, this method is not chainable.
     */
    this.set = function(name, value) {
      var fn, key, props, i;
      if (typeof name === 'string') {
        fn = setters[name];
        if (fn) {
          fn(name, value);
        }
      } else if (typeof name === 'object') {
        props = Object.keys(name);
        for(i=0; i<props.length; ++i) {
          key = props[i];
          fn = setters[key];
          if (fn) {
            fn(key, name[key]);
          }
        }
      }
    };
  })

  /**
   * @ngdoc directive
   * @name ui.comments.directive:comments
   * @restrict EA
   * @element div
   * @scope
   *
   * @param {expression} comment-data Data model containing a collection of comments.
   * @param {string} order-by Override the default orderBy value.
   * @param {number} comment-depth-limit The maximum depth of nested comments tree to display.
   *   default: 5
   *
   * @description
   *
   * This directive is replaced by the transcluded
   * {@link ui.comments.commentsConfig#containerTemplate containerTemplate} from
   * {@link ui.comments.commentsConfig commentsConfig}.
   *
   * The comments container produces an isolate scope, and injected into the isolate scope is the
   * the following:
   *
   * - _comments_: Collection of comments, shared with the parent scope.
   *
   * **TODO**: Expose the child-container status in _status_, so that it may be ng-if'd in templates.
   *
   * The container should contain an `ng-repeat` directive for child comments. A very simple example
   * of the {@link ui.comments.commentsConfig#containerTemplate containerTemplate} might look like
   * the following:
   *
   * <pre>
   * <div class="comments">
   *   <comment ng-repeat="comment in comments" comment-data="comment"></comment>
   * </div>
   * </pre>
   */
  app.directive('comments', function($compile, $interpolate, commentsConfig) {
    return {
      restrict: 'EA',
      require: '?^comment',
      transclude: true,
      replace: true,
      templateUrl: function() { return commentsConfig.containerTemplate; },
      scope: {
        'comments': '=commentData'
      },
      controller: function() {},
      link: {
        pre: function(scope, elem, attr, comment) {
          var self = elem.controller('comments'),
              parentCollection = comment ? comment.comments : null;

          // Setup $commentsController
          if (parentCollection) {
            self.commentsDepth = parentCollection.commentsDepth + 1;
            self.commentsRoot = parentCollection.commentsRoot;
            self.commentsParent = parentCollection;
          } else {
            self.commentsDepth = 1;
            self.commentsRoot = null;
            var depthLimit = angular.isDefined(attr.commentDepthLimit) ?
                             attr.commentDepthLimit :
                             commentsConfig.depthLimit;
            if (typeof depthLimit === 'string') {
              depthLimit = $interpolate(depthLimit, false)(scope.$parent);
              if (typeof depthLimit === 'string') {
                depthLimit = parseInt(depthLimit, 10);
              }
            }

            if (typeof depthLimit !== 'number' || depthLimit !== depthLimit) {
              // Avoid NaN and non-numbers
              depthLimit = 0;
            }

            self.commentsDepthLimit = depthLimit;
          }

          scope.commentsDepth = self.commentsDepth;
          attr.$observe('orderBy', function(newval, oldval) {
            scope.commentOrder = newval || commentsConfig.orderBy;
          });
        }
      }
    };
  })

  /**
   * @ngdoc directive
   * @name ui.comments.directive:comment
   * @restrict EA
   * @element div
   * @scope
   *
   * @param {expression} comment-data Data model containing the specific comment.
   *
   * @description
   *
   * The {@link ui.comments.directive:comment comment} directive is primarily used automatically by
   * the {@link ui.comments.directive:comments comments} directive, by automatically
   * building comment directives for each element in the collection.
   *
   * When a {@link ui.comments.commentsConfig#commentController commentController} is specified in
   * {@link ui.comments.commentsConfig commentsConfig}, it is instantiated for each comment. The
   * comment data is exposed to scope through {@link ui.comments.directive:comment comment}, and so
   * templates may access comment properties through expressions like `comment.text`.
   *
   * An example template might look like the following:
   * <pre>
   * <div class="comment">
   *   <div class="comment-header">
   *    <a class="comment-avatar"
   *       ng-href="{{comment.profileUrl}}">
   *      <img ng-src="{{comment.avatarUrl}}"
   *           alt="{{comment.name}}" />
   *    </a>
   *    <a class="comment-username"
   *       ng-href="{{comment.profileUrl}}"
   *       title="{{comment.username}}">{{comment.name}}</a>
   *     <span class="comment-date">{{comment.date | timeAgo}}</span>
   *   </div>
   *   <div class="comment-body" ng-bind="comment.text"></div>
   * </div>
   * </pre>
   *
   * **IMPORANT**: Do **not** use the {@link ui.comments.directive:comments comments} directive in a
   * {@link ui.comments.commentsConfig#commentTemplate commentTemplate}. This will cause an
   * infinite {@link http://docs.angularjs.org/api/ng.$compile $compile} loop, and eat a lot of
   * memory.
   */
  app.directive('comment', function($compile, commentsConfig, $controller, $exceptionHandler, $timeout) {
    return {
      require: ['^comments', 'comment'],
      restrict: 'EA',
      transclude: true,
      replace: true,
      templateUrl: function() { return commentsConfig.commentTemplate; },
      scope: {
        comment: '=commentData'
      },
      controller: function($scope) {},
      link: function(scope, elem, attr, ctrls) {
        var comments = ctrls[0], comment = ctrls[1];
        var controller = commentsConfig.commentController, controllerInstance;

        scope.commentDepth = comments.commentsDepth;
        scope.commentDepthLimit = (comments.commentsRoot || comments).commentsDepthLimit;
        comment.comments = comments;

        if (controller) {
          controllerInstance = $controller(controller, {
            '$scope': scope,
            '$element': elem
          });
          if (controllerInstance) {
            elem.data('$CommentController', controllerInstance);
          }
        }
        if (elem.parent().attr('child-comments') === 'true') {
          elem.addClass('child-comment');
        }
        var children = false, compiled,
            sub = $compile('<div comments child-comments="true" ' +
                           'comment-data="comment.children"></div>'),
            transclude;
        // Notify controller without bubbling
        function notify(scope, name, data) {
          if (!controllerInstance) { return; }
          var namedListeners = scope.$$listeners[name] || [], i, length, args = [data];
          for (i=0, length=namedListeners.length; i<length; i++) {
            // if listeners were deregistered, defragment the array
            if (!namedListeners[i]) {
              namedListeners.splice(i, 1);
              i--;
              length--;
              continue;
            }
            try {
              //allow all listeners attached to the current scope to run
              namedListeners[i].apply(null, args);
            } catch (e) {
              $exceptionHandler(e);
            }
          }
        }
        function update(data) {
          if (!angular.isArray(data)) {
            data = [];
          }
          if (data.length > 0 && !children) {
            if (comments.commentsDepth >= (comments.commentsRoot || comments).commentsDepthLimit) {
              notify(scope, '$depthLimitComments', scope.comment);
              return;
            }
            compiled = sub(scope, function(dom) {
              if (comment.commentsTransclude) {
                transclude = comment.commentsTransclude.clone(true);
                comment.commentsTransclude.replaceWith(dom);
              } else {
                elem.append(dom);
              }
            });
            children = true;
            notify(scope, '$filledNestedComments', compiled);
          } else if(!data.length && children) {
            children = false;
            if (comment.commentsTransclude && transclude) {
              compiled.replaceWith(transclude);
            } else {
              compiled.remove();
            }
            notify(scope, '$emptiedNestedComments', comment.commentsTransclude || elem);
            transclude = compiled = undefined;
          }
        }
        
        scope.$watch('comment', function(newval) {
          update(scope.comment.children);
        }, true);
      }
    };
  })

  /**
   * @ngdoc directive
   * @name ui.comments.directive:commentsTransclude
   * @restrict EA
   * @element div
   *
   * @description
   *
   * This directive is a helper which allows a user to specify in a
   * {@link ui.comments.directive:comment comment} template where they wish child comments to be
   * inserted.
   *
   * If this directive is not used, then the child comments are merely appended to the end of a
   * comment template, which is the behaviour of the default templates.
   *
   * It is not a literal transclusion, and so any class names or categories are completely ignored.
   * Instead, the element is replaced by a {@link ui.comments.directive:comments comments} collection
   * when comments are available.
   *
   * An example template might look like the following:
   * <pre>
   * <div class="comment">
   *   <div class="comment-header">
   *    <a class="comment-avatar"
   *       ng-href="{{comment.profileUrl}}">
   *      <img ng-src="{{comment.avatarUrl}}"
   *           alt="{{comment.name}}" />
   *    </a>
   *    <a class="comment-username"
   *       ng-href="{{comment.profileUrl}}"
   *       title="{{comment.username}}">{{comment.name}}</a>
   *     <span class="comment-date">{{comment.date | timeAgo}}</span>
   *   </div>
   *   <div class="comment-body" ng-bind="comment.text"></div>
   *   <div comments-transclude></div>
   * </div>
   * </pre>
   */
  app.directive('commentsTransclude', function() {
    return {
      restrict: 'EA',
      require: '^comment',
      link: function(scope, element, attr, comment) {
        attr.$addClass('comments-transclude');
        comment.commentsTransclude = element;
      }
    };
  });

  app.directive('timer', ['$compile', function ($compile) {
    return  {
      restrict: 'EAC',
      replace: false,
      scope: {
        interval: '=interval',
        startTimeAttr: '=startTime',
        endTimeAttr: '=endTime',
        countdownattr: '=countdown',
        finishCallback: '&finishCallback',
        autoStart: '&autoStart',
        maxTimeUnit: '='
      },
      controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {

        // Checking for trim function since IE8 doesn't have it
        // If not a function, create tirm with RegEx to mimic native trim
        if (typeof String.prototype.trim !== 'function') {
          String.prototype.trim = function () {
            return this.replace(/^\s+|\s+$/g, '');
          };
        }

        //angular 1.2 doesn't support attributes ending in "-start", so we're
        //supporting both "autostart" and "auto-start" as a solution for
        //backward and forward compatibility.
        $scope.autoStart = $attrs.autoStart || $attrs.autostart;

        if ($element.html().trim().length === 0) {
          $element.append($compile('<span>{{millis}}</span>')($scope));
        } else {
          $element.append($compile($element.contents())($scope));
        }

        $scope.startTime = null;
        $scope.endTime = null;
        $scope.timeoutId = null;
        $scope.countdown = $scope.countdownattr && parseInt($scope.countdownattr, 10) >= 0 ? parseInt($scope.countdownattr, 10) : undefined;
        $scope.isRunning = false;

        $scope.$on('timer-start', function () {
          $scope.start();
        });

        $scope.$on('timer-resume', function () {
          $scope.resume();
        });

        $scope.$on('timer-stop', function () {
          $scope.stop();
        });

        $scope.$on('timer-clear', function () {
          $scope.clear();
        });

        $scope.$on('timer-set-countdown', function (e, countdown) {
          $scope.countdown = countdown;
        });

        function resetTimeout() {
          if ($scope.timeoutId) {
            clearTimeout($scope.timeoutId);
          }
        }

        $scope.start = $element[0].start = function () {
          $scope.startTime = $scope.startTimeAttr ? new Date($scope.startTimeAttr) : new Date();
          $scope.endTime = $scope.endTimeAttr ? new Date($scope.endTimeAttr) : null;
          if (!$scope.countdown) {
            $scope.countdown = $scope.countdownattr && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : undefined;
          }
          resetTimeout();
          tick();
          $scope.isRunning = true;
        };

        $scope.resume = $element[0].resume = function () {
          resetTimeout();
          if ($scope.countdownattr) {
            $scope.countdown += 1;
          }
          $scope.startTime = new Date() - ($scope.stoppedTime - $scope.startTime);
          tick();
          $scope.isRunning = true;
        };

        $scope.stop = $scope.pause = $element[0].stop = $element[0].pause = function () {
          var timeoutId = $scope.timeoutId;
          $scope.clear();
          $scope.$emit('timer-stopped', {timeoutId: timeoutId, millis: $scope.millis, seconds: $scope.seconds, minutes: $scope.minutes, hours: $scope.hours, days: $scope.days});
        };

        $scope.clear = $element[0].clear = function () {
          // same as stop but without the event being triggered
          $scope.stoppedTime = new Date();
          resetTimeout();
          $scope.timeoutId = null;
          $scope.isRunning = false;
        };

        $element.bind('$destroy', function () {
          resetTimeout();
          $scope.isRunning = false;
        });

        function calculateTimeUnits() {
          if ($attrs.startTime !== undefined){
            $scope.millis = new Date() - new Date($scope.startTimeAttr);
          }
          // compute time values based on maxTimeUnit specification
          if (!$scope.maxTimeUnit || $scope.maxTimeUnit === 'day') {
            $scope.seconds = Math.floor(($scope.millis / 1000) % 60);
            $scope.minutes = Math.floor((($scope.millis / (60000)) % 60));
            $scope.hours = Math.floor((($scope.millis / (3600000)) % 24));
            $scope.days = Math.floor((($scope.millis / (3600000)) / 24));
            $scope.months = 0;
            $scope.years = 0;
          } else if ($scope.maxTimeUnit === 'second') {
            $scope.seconds = Math.floor($scope.millis / 1000);
            $scope.minutes = 0;
            $scope.hours = 0;
            $scope.days = 0;
            $scope.months = 0;
            $scope.years = 0;
          } else if ($scope.maxTimeUnit === 'minute') {
            $scope.seconds = Math.floor(($scope.millis / 1000) % 60);
            $scope.minutes = Math.floor($scope.millis / 60000);
            $scope.hours = 0;
            $scope.days = 0;
            $scope.months = 0;
            $scope.years = 0;
          } else if ($scope.maxTimeUnit === 'hour') {
            $scope.seconds = Math.floor(($scope.millis / 1000) % 60);
            $scope.minutes = Math.floor((($scope.millis / (60000)) % 60));
            $scope.hours = Math.floor($scope.millis / 3600000);
            $scope.days = 0;
            $scope.months = 0;
            $scope.years = 0;
          } else if ($scope.maxTimeUnit === 'month') {
            $scope.seconds = Math.floor(($scope.millis / 1000) % 60);
            $scope.minutes = Math.floor((($scope.millis / (60000)) % 60));
            $scope.hours = Math.floor((($scope.millis / (3600000)) % 24));
            $scope.days = Math.floor((($scope.millis / (3600000)) / 24) % 30);
            $scope.months = Math.floor((($scope.millis / (3600000)) / 24) / 30);
            $scope.years = 0;
          } else if ($scope.maxTimeUnit === 'year') {
            $scope.seconds = Math.floor(($scope.millis / 1000) % 60);
            $scope.minutes = Math.floor((($scope.millis / (60000)) % 60));
            $scope.hours = Math.floor((($scope.millis / (3600000)) % 24));
            $scope.days = Math.floor((($scope.millis / (3600000)) / 24) % 30);
            $scope.months = Math.floor((($scope.millis / (3600000)) / 24 / 30) % 12);
            $scope.years = Math.floor(($scope.millis / (3600000)) / 24 / 365);
          }
          // plural - singular unit decision
          $scope.secondsS = ($scope.seconds === 1 || $scope.seconds === 0) ? '' : 's';
          $scope.minutesS = ($scope.minutes === 1 || $scope.minutes === 0) ? '' : 's';
          $scope.hoursS = ($scope.hours === 1 || $scope.hours === 0) ? '' : 's';
          $scope.daysS = ($scope.days === 1 || $scope.days === 0)? '' : 's';
          $scope.monthsS = ($scope.months === 1 || $scope.months === 0)? '' : 's';
          $scope.yearsS = ($scope.years === 1 || $scope.years === 0)? '' : 's';
          //add leading zero if number is smaller than 10
          $scope.sseconds = $scope.seconds < 10 ? '0' + $scope.seconds : $scope.seconds;
          $scope.mminutes = $scope.minutes < 10 ? '0' + $scope.minutes : $scope.minutes;
          $scope.hhours = $scope.hours < 10 ? '0' + $scope.hours : $scope.hours;
          $scope.ddays = $scope.days < 10 ? '0' + $scope.days : $scope.days;
          $scope.mmonths = $scope.months < 10 ? '0' + $scope.months : $scope.months;
          $scope.yyears = $scope.years < 10 ? '0' + $scope.years : $scope.years;

        }

        //determine initial values of time units and add AddSeconds functionality
        if ($scope.countdownattr) {
          $scope.millis = $scope.countdownattr * 1000;

          $scope.addCDSeconds = $element[0].addCDSeconds = function (extraSeconds) {
            $scope.countdown += extraSeconds;
            $scope.$digest();
            if (!$scope.isRunning) {
              $scope.start();
            }
          };

          $scope.$on('timer-add-cd-seconds', function (e, extraSeconds) {
            $timeout(function () {
              $scope.addCDSeconds(extraSeconds);
            });
          });

          $scope.$on('timer-set-countdown-seconds', function (e, countdownSeconds) {
            if (!$scope.isRunning) {
              $scope.clear();
            }

            $scope.countdown = countdownSeconds;
            $scope.millis = countdownSeconds * 1000;
            calculateTimeUnits();
          });
        } else {
          $scope.millis = 0;
        }
        calculateTimeUnits();

        var tick = function () {

          $scope.millis = new Date() - $scope.startTime;
          var adjustment = $scope.millis % 1000;

          if ($scope.endTimeAttr) {
            $scope.millis = $scope.endTime - new Date();
            adjustment = $scope.interval - $scope.millis % 1000;
          }


          if ($scope.countdownattr) {
            $scope.millis = $scope.countdown * 1000;
          }

          if ($scope.millis < 0) {
            $scope.stop();
            $scope.millis = 0;
            calculateTimeUnits();
            if($scope.finishCallback) {
              $scope.$eval($scope.finishCallback);
            }
            return;
          }
          calculateTimeUnits();

          //We are not using $timeout for a reason. Please read here - https://github.com/siddii/angular-timer/pull/5
          $scope.timeoutId = setTimeout(function () {
            tick();
            $scope.$digest();
          }, $scope.interval - adjustment);

          $scope.$emit('timer-tick', {timeoutId: $scope.timeoutId, millis: $scope.millis});

          if ($scope.countdown > 0) {
            $scope.countdown--;
          }
          else if ($scope.countdown <= 0) {
            $scope.stop();
            if($scope.finishCallback) {
              $scope.$eval($scope.finishCallback);
            }
          }
        };

        if ($scope.autoStart === undefined || $scope.autoStart === true) {
          $scope.start();
        }
      }]
    };
  }]);


})();